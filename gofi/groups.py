from typing import Any
from gofi.autograd.models import GeneratorModel, GeneratorGroup
from math import factorial
from collections import deque
from typing import Tuple

Permutation = Tuple[int, ...]

def compose(p: Permutation, q: Permutation) -> Permutation:
    """Composition p âˆ˜ q"""
    return tuple(p[i] for i in q)


class Group:
    """
    Class representing a group, given by generators and relations.
    """

    def __init__(
        self,
        generators: list[tuple[Any]],
        relations: list[list[Any]],
        table : list | None = None 
    ) -> None:
        """
        Creates a group, given by generators and relations.

        Parameters
        ----------
        generators : list
            List of generators.
        relations : list[list[Any]]
            List of relations of generators.
        table : list
            Table of all the elemets in the group.

        Example usage - S3
        -------------
        S3 is generated by transpositions a=(1,2) and b=(1,3).
        Elemets of S3 are: id, a, b, aba, ab, ba.

        Relations, that define S3, are: a^2=b^2=ababab=0.
        Replaced by indices, this yields `relations  =[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]]`.
        >>> S3 = GeneratorGroup(
            generators = [(1, 2), (1, 3)],
            relations  =[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]],
            table = [[], [0], [1], [0, 1, 0], [0, 1], [1, 0]]
            )

        """
        self.generators = generators
        self.n_generators = len(generators)
        self.relations = relations
        self.table = table 
        self.size = len(table)

    def __str__(self) -> str:
        return f"Group of size {self.size} with generators {self.generators} and relations {self.relations}"

def enumerate_Sn_words(n: int):
    """
    Enumerate S_n using generators:
        s = (1 2)
        t = (1 2 ... n)

    Returns:
        elements: list[tuple[str, ...]]
    """
    if n < 3:
        raise ValueError("n must be >= 3")

    # identity
    id_perm = tuple(range(n))

    # generators as permutations
    s_perm = list(range(n))
    s_perm[0], s_perm[1] = s_perm[1], s_perm[0]
    s_perm = tuple(s_perm)

    t_perm = tuple(range(1, n)) + (0,)

    gens = {
        "s": s_perm,
        "t": t_perm,
    }

    # BFS
    seen = {id_perm: ()}
    queue = deque([id_perm])

    while queue:
        g = queue.popleft()
        word = seen[g]

        for name, perm in gens.items():
            h = compose(perm, g)
            if h not in seen:
                seen[h] = word + (name,)
                queue.append(h)

    return list(seen.values())



demo_S3 = GeneratorGroup(
            generators=[(1, 2), (1, 3)],
            relations=[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]],
             table = [[], [0], [1], [0, 1, 0], [0, 1], [1, 0]]
        )


demo_C3 = GeneratorGroup(
            generators=["s"],
            relations=[[0,0,0]],
             table = [[], [0], [0,0]]
        )


def coxeter_presentation(n: int) -> GeneratorGroup:
    """
    S_n with two generators via Coxeter-type presentation,
    including full enumeration of elements.
    """
    generators = ["s", "t"]

    relations = [
        "ss",
        "t" * n,
        ("st") * (n - 1),
    ]

    elements = enumerate_Sn_words(n)

    return GeneratorGroup(
        generators=generators,
        relations=relations,
        table=elements,
    )

    

def get_S_n(n):
    return coxeter_presentation(n)
