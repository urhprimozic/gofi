import torch
import torch.nn as nn
from gofi.autograd.torch_settings import device
import numpy as np


class GeneratorGroup:
    """
    Class representing a group, given by generators and relationship.

    Authors: Matej Petković, Urh Primožič
    """

    def __init__(
        self,
        generators: list[tuple[int]],
        relations: list[list[int]],
        table : list 
    ) -> None:
        """
        Creates a group, given by generators and relations.

        Parameters
        ----------
        generators : list
            List of generators.
        relations : list[list[int]]
            List of relations of generators.
        table : list
            Table of all the elemets in the group.

        Example usage - S3
        -------------
        S3 is generated by transpositions a=(1,2) and b=(1,3).
        Elemets of S3 are: id, a, b, aba, ab, ba.

        Relations, that define S3, are: a^2=b^2=ababab=0.
        Replaced by indices, this yields `relations  =[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]]`.
        >>> S3 = GeneratorGroup(
            generators = [(1, 2), (1, 3)],
            relations  =[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]],
            table = [[], [0], [1], [0, 1, 0], [0, 1], [1, 0]]
            )

        """
        self.generators = generators
        self.n_generators = len(generators)
        self.relations = relations
        self.table = table 
        self.size = len(table)

    def __str__(self) -> str:
        return f"Group of size {self.size} with generators {self.generators} and relations {self.relations}"


class GeneratorModel(nn.Module):
    """
    Creates a model of representation G -> GL_n for G `GeneratorGroup`.
    Maps every group generator to a different matrix.

    Implements gradient descend on matrices.

    Authors: Matej Petković, Urh
    """

    def __init__(
        self,
        group: GeneratorGroup,
        dim: int,
        initial_params: torch.Tensor | None = None,
        params_shape=None,
        param_to_matrix=None,
        complex=False
    ):
        """
        Creates a new model of dim-dimensional representation of group.
        Models a representation G -> GL_dim .

        Saves mapping of its generators inside tensor `self.weights` of shape `(group.n_generators, dim, dim)`.

        Parameters
        ------------
        group : GeneratorGroup
            Group G
        dim : int
            Dimension of the modeled representation. Equal to the matrix size of matrices.
        initial_params : torch.Tensor | None = None
            Initial weights. Should be of shape (group.n_generators, dim, dim).
            If None, weights are sampled from Normal(0, 0.1) distribution.

        params_shape : torch.Size | None=None
            Shape of the parameters of the model. If None, parameters = matrices.
            If not none, param_to_matrix is used to map self.weights to matrices.
            param_shape should be [group.n_generators, *]. Default value is [group.n_generators, dim, dim]

        param_to_matrix : function |None
            Function, which maps params[index] to matrix. If this is none or params_shape is None, identity is used.
            Otherwise: Representation(g) = param_to_matrix(parameters[g])
        
        complex : bool (default = False)
            If True, the model is parametrised by complex numbers.
            If False, the model is parametrised by real numbers.

        """
        super().__init__()
        self.group = group
        self.dim = dim

        self.dtype = torch.complex64 if complex else torch.float32

        if params_shape is None:
            params_shape = torch.Size([group.n_generators, dim, dim])
        if param_to_matrix is None:
            param_to_matrix = lambda x: x

        self.params_shape = params_shape
        self.param_to_matrix = param_to_matrix

        if initial_params is None:
            weights = torch.rand(params_shape, dtype=self.dtype).to(device)
            # scale weights between - and 
            weights = - 1 + 2 * weights
        else:

            # set weights to initial params
            weights = initial_params
        # create nn.Parameter
        self.weights = nn.Parameter(weights)
    
    def get_new(self, initial_params : torch.Tensor | None):
        return GeneratorModel(self.group, self.dim, initial_params=initial_params, params_shape=initial_params.shape, param_to_matrix=self.param_to_matrix)

    def forward(self, xs: list[int]):
        """
        Returns matrix products of matrices, corresponding to generators, whose indices are in xs.

        Parameters
        -----------
        xs : list[int]
            List of indices of generators.

        Example usage
        --------------
        >>> S3 = GeneratorGroup(
            generators = [(1, 2), (1, 3)],
            relations  =[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]],
            table = [[], [0], [1], [0, 1, 0], [0, 1], [1, 0]]
            )
        # model of 2-dimensional representation
        >>> M = GeneratorModel(S3, 2)
        >>> pi = [0,1,0] # pi = (1, 2)(1,3)(1, 2)
        >>> M(pi) = TODO


        """
        return self.get_matrix_of_product(xs)

    def get_matrix_for_element(self, element):
        raise DeprecationWarning("get_matrix_for_element is deprecadet. Please use ")
        return self.get_matrix_of_generator(element)

    # return self.weights[:, element * self.dim : (element + 1) * self.dim]

    def get_matrix_of_generator(self, index: int):
        """
        Returns matrix, which represents generator at index.

        Parameters
        ----------
        index : int
            Index of the generator inside self.group.generators.

        """
        # self.weights.shape = (self.n_generators, dim, dim).
        # First dimension encodes different generators

        # params of generator at index
        param = self.weights[index]
        # mat param to matrix
        matrix = self.param_to_matrix(param)
        if not (matrix.shape == torch.Size([self.dim, self.dim])):
            raise ValueError(
                f"Shape of param_to_matrix(weights[{index}]) is {matrix.size}, but should be {torch.Size([self.dim, self.dim])}."
            )
        return matrix

    def get_matrix_of_product(self, product: list[int]):
        """
        Returns matrix products of matrices, corresponding to generators, whose indices are in xs.

        Computes `matrix_product(get_matrix_of_generator(index) for index in product  )`

        Parameters
        -----------
        xs : list[int]
            List of indices of generators.

        Example usage
        --------------
        >>> S3 = GeneratorGroup(
            generators = [(1, 2), (1, 3)],
            relations  =[[0, 0], [1, 1], [0, 1, 0, 1, 0, 1]],
            table = [[], [0], [1], [0, 1, 0], [0, 1], [1, 0]]
            )
        # model of 2-dimensional representation
        >>> M = GeneratorModel(S3, 2)
        >>> pi = [0,1,0] # pi = (1, 2)(1,3)(1, 2)
        >>> M(pi) = TODO

        """
        if type(product) == int:
            raise ValueError(f"Input product {product} has type int, but should be a list. Did you mean to use [{product}]?")

        # empty product represents id
        if not product:
            return torch.eye(self.dim)
        else:
            matrix = self.get_matrix_of_generator(product[0])
            for i in product[1:]:
                matrix = torch.matmul(matrix, self.get_matrix_of_generator(i))
            return matrix

    @staticmethod
    def get_matrix_of_product_static(product: list[int], weights: np.ndarray):
        """
        Returns matrix product (weights[i] for i in product)
        """
        # collect dimensions
        _, dim, _ = weights.shape

        matrix = np.eye(dim)

        for element in product:

            matrix = matrix @ weights[element]
        return matrix
