import itertools
import torch
from math import factorial

def adjacency_matrix_to_edges_list(M):
    edges = []
    n = M.shape[0]
    for i in range(n):
        for j in range(n):
            if j > i:
                break
            if M[i][j] == 1:
                edges.append((i + 1 ,j + 1)) # index edges with 1!
    return edges

def compose_permutation(p, q):
    """Return the composition p ∘ q (first q, then p) for permutations
    stored as tuples whose i-th entry is the image of i+1."""
    return tuple(p[q[i] - 1] for i in range(len(p)))

def inverse_permutation(p):
    """Inverse of a permutation given in tuple form."""
    inv = [0] * len(p)
    for i, x in enumerate(p):
        inv[x - 1] = i + 1
    return tuple(inv)

def adjacency_matrix_cayley_Sn(n: int):
    """
    Return the edge list of the (undirected) Cayley graph of S_n
    with generators a = (1 2) and b = (1 2 … n).  Vertices are
    indexed 0 … n!−1 in lexicographic order of permutations.
    Each edge is an ordered pair (i, j) with i < j.
    """
    if n < 2:
        raise ValueError("n must be at least 2")

    # all permutations of 1…n in lexicographic order
    perms = list(itertools.permutations(range(1, n + 1)))
    index = {p: k for k, p in enumerate(perms)}

    # generators
    a = tuple([2, 1, *range(3, n + 1)])          # (1 2)
    b = tuple([*range(2, n + 1), 1])             # (1 2 … n)
    b_inv = inverse_permutation(b)                           # (1 n … 2)

    edges = set()
    for p in perms:
        i = index[p]
        for g in (a, b, b_inv):
            j = index[compose_permutation(g, p)]
            if i < j:
                edges.add((i, j))

    # return a list sorted for reproducibility
    edges = sorted(edges)
    # convert to matrix
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    m = factorial(n)
    M = torch.zeros((m, m), device=device)
    for i, j in edges:
        M[i,j] = 1
        M[j, i] = 1
    return M

def random_adjacency_matrix(n : int):
    """
    Returns adjacency matrix of a random undirected graph with n vertices.
    The graph is generated by randomly choosing edges between vertices.
    The probability of an edge between any two vertices is 0.5.
    
    """
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    M = torch.rand(n, n, device=device)
    M = (M + M.T) / 2  # make it symmetric
    M[M < 0.5] = 0
    M[M >= 0.5] = 1
    # set diagonal to 0
    for i in range(n):
        M[i, i] = 0
    return M